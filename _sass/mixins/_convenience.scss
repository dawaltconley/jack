@mixin mq($breakpoints: $bp, $queries: (lt: max, gt: min)) {
    @if type-of(nth($breakpoints, 1)) == "string" {
        $new-breakpoints: ();
        @for $i from 1 through length($breakpoints) {
            $name: nth($breakpoints, $i);
            @if map-has-key($bp, $name) {
                $new-breakpoints: map-merge($new-breakpoints, ($name: map-get($bp, $name)));
            } @else {
                @warn "No value in $bp corresponding to breakpoint name '#{$name}', skipping.";
            }
        }
        $breakpoints: $new-breakpoints;
    }
    @each $prefix, $query in $queries {
        $sorted-bp: map-sort-units($breakpoints, $order: px em);
        @for $i from 1 through length($sorted-bp) {
            $unit-set: map-sort(nth($sorted-bp, $i));
            @if $query == "max" {
                $unit-set: map-reverse($unit-set);
            }
            $sorted-bp: set-nth($sorted-bp, $i, $unit-set);
        }
        $sorted-bp: merge-all($sorted-bp);

        @each $name, $breakpoint in $sorted-bp {
            @if ($query == "min") and (index('px', unit($breakpoint))) {
                $breakpoint: $breakpoint + 1;
            }

            &-#{$prefix}-#{$name} {
                @media screen and (#{$query}-width: $breakpoint) {
                    @content;
                }
            }
        }
    }
}

@mixin fixed-ratio($x, $y, $width: 100%) {
    width: $width;
    height: 0;
    padding-top: $y/$x * $width;
}

@mixin columns-reset($break-point) { // mobile reset
    @media screen and (max-width: $break-point) {
        .cell {
            display: block;

            .button {
                position: static;
                margin: 0 auto $default-spacing;
            }

            &:last-child > :last-child { // mobile only: remove bottom margin of last element in table
                margin-bottom: 0;
            }
        }

        &.button-columns .cell {
            padding-bottom: 0;
        }
    }

    @media screen and (min-width: $break-point + 1px) { // desktop only: remove bottom margin of all last element in each cell
        .cell > :last-child {
            margin-bottom: 0;
        }
    }
}

@mixin columns ($columns, $spacing: 0px) {
    @if not($columns > 1) { @error "columns mixin must have more than one column." }
    $width: 100% / $columns;
    $row-end: $columns + "n";
    width: calc(#{$width} - #{($spacing * ($columns - 1) / $columns)});
    margin-right: $spacing;
    margin-bottom: $spacing;

    &:nth-child(#{$row-end}), &:last-child {
        margin-right: 0;
    }
}

@mixin inline-columns($breakpoints, $spacing: null) {
    $bp-col-map: ();
    @extend .font-0;

    > * {
        @extend .inline-block, .full-width;
        margin-bottom: $spacing;

        @for $i from 1 through length($breakpoints) {
            $breakpoint: nth($breakpoints, $i);
            $columns: null;
            @if length($breakpoint) > 2 {
                @error "the responsive-columns mixin only accepts one or two items per breakpoint: the breakpoint and (optionally) the number of columns.";
            } @else if length($breakpoint) == 2 {
                $columns: nth($breakpoint, 2);
                $breakpoint: nth($breakpoint, 1);
            } @else if type-of($breakpoint) == map {
                $columns: nth(map-values($breakpoint), 1);
                $breakpoint: nth(map-keys($breakpoint), 1);
            }

            @if type-of($breakpoint) == string and map-has-key($bp, $breakpoint) {
                $breakpoint: map-get($bp, $breakpoint);
            } @else if type-of($breakpoint) == string {
                @error 'responsive-columns mixin: breakpoint name #{$breakpoint} is not a valid breakpoint name; must match a key in the global $bp map.'
            } @else if type-of($breakpoint) != number {
                @error 'responsive-columns mixin: breakpoint must be either a number or a string identifier; encountered #{$breakpoint} which is a #{type-of($breakpoint)}'
            }

            $bp-col-map: map-merge($bp-col-map, ($breakpoint: $columns));
        }

        $bp-col-map: map-sort($bp-col-map, keys);
        $last-col: 1;

        @for $i from 1 through length($bp-col-map) {
            $bp: nth(nth($bp-col-map, $i), 1);
            $col: nth(nth($bp-col-map, $i), 2);
            @if not $col { $col: $last-col + 1; }
            $query: "screen and (min-width: #{$bp})";
            @if $i < length($bp-col-map) {
                $bp-next: nth(nth($bp-col-map, $i+1), 1);
                $query: "#{$query} and (max-width: #{$bp-next - 1px})";
                $last-col: $col;
            }
            @media #{$query} {
                @include columns($col, $spacing);
            }
        }
    }
}

@mixin blur($blur) {
    -webkit-filter: blur($blur);
    filter: blur($blur);
}

// This mixin applies the effects its contents when a element
// with class "hover" (either same element or nearest parent) is hovered
@mixin hover($hover-class: "hover") {
    @at-root &.#{$hover-class}:hover,
    #{last-selector(&, ".#{$hover-class}:hover >", ":not(.#{$hover-class})")},
    #{last-selector(&, ".#{$hover-class}:hover *:not(.#{$hover-class})", ":not(.#{$hover-class})")} {
        @content;
    }
}

@mixin no-hover($hover-class: "hover") {
    @at-root &.#{$hover-class}:not(:hover),
    #{last-selector(&, ".#{$hover-class}:not(:hover) >", ":not(.#{$hover-class})")},
    #{last-selector(&, ".#{$hover-class}:not(:hover) *:not(.#{$hover-class})", ":not(.#{$hover-class})")} {
        @content;
    }
}

// same idea with a target class
@mixin target($target-class: "target") {
    @at-root &.#{$target-class}:target,
    #{last-selector(&, ".#{$target-class}:target >", ":not(.#{$target-class})")},
    #{last-selector(&, ".#{$target-class}:target *:not(.#{$target-class})", ":not(.#{$target-class})")} {
        @content;
    }
}

@mixin no-target($target-class: "target") {
    @at-root &.#{$target-class}:not(:target),
    #{last-selector(&, ".#{$target-class}:not(:target) >", ":not(#{$target-class})")},
    #{last-selector(&, ".#{$target-class}:not(:target) *:not(.#{$target-class})", ":not(.#{$target-class})")} {
        @content;
    }
}

@mixin transform($transform) {
    -webkit-transform: $transform;
    transform: $transform;

    &.hw-accel {
        -webkit-transform: $transform translateZ(0);
        transform: $transform translateZ(0);
    }
}
